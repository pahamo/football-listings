{"ast":null,"code":"import { supabase } from './supabase';\n\n// Simple, minimal types\n\n// Only Sky Sports and TNT Sports for simplicity\nexport const SIMPLE_BROADCASTERS = [{\n  id: 1,\n  name: 'Sky Sports'\n}, {\n  id: 2,\n  name: 'TNT Sports'\n}];\n\n// Get fixtures with basic team info using simple JOINs\nexport async function getSimpleFixtures() {\n  try {\n    console.log('[Supabase] Loading full season fixtures (no JOINs)...');\n\n    // Step 1: Load fixture basics only\n    // Use a dynamic season start (Aug 1 of current season year)\n    const now = new Date();\n    const seasonYear = now.getUTCMonth() >= 6 ? now.getUTCFullYear() : now.getUTCFullYear() - 1;\n    const seasonStartIso = `${seasonYear}-08-01T00:00:00.000Z`;\n    const {\n      data: fixtures,\n      error\n    } = await supabase.from('fixtures_with_teams').select('id, utc_kickoff, home_team_id, away_team_id, home_team, away_team, matchday').gte('utc_kickoff', seasonStartIso).order('utc_kickoff', {\n      ascending: true\n    });\n    if (error) {\n      console.error('[Supabase] Error loading fixtures:', error);\n      throw error;\n    }\n    if (!fixtures || fixtures.length === 0) {\n      console.warn('[Supabase] No fixtures returned');\n      return [];\n    }\n\n    // Step 2: Load team names in one query\n    const teamIds = Array.from(new Set([...fixtures.map(f => f.home_team_id), ...fixtures.map(f => f.away_team_id)].filter(Boolean)));\n    let teamNameById = {};\n    if (teamIds.length > 0) {\n      const {\n        data: teams,\n        error: teamError\n      } = await supabase.from('teams').select('id, name').in('id', teamIds);\n      if (teamError) {\n        console.warn('[Supabase] Error loading teams:', teamError);\n      } else {\n        (teams || []).forEach(t => {\n          teamNameById[t.id] = t.name;\n        });\n      }\n    }\n\n    // Step 3: Load broadcasts for these fixtures\n    const fixtureIds = fixtures.map(f => f.id);\n    const {\n      data: broadcasts\n    } = await supabase.from('broadcasts').select('fixture_id, provider_id').in('fixture_id', fixtureIds);\n    const broadcastLookup = {};\n    (broadcasts || []).forEach(b => {\n      broadcastLookup[b.fixture_id] = b.provider_id;\n    });\n\n    // Step 4: Map to simple format\n    return fixtures.map(fixture => {\n      var _SIMPLE_BROADCASTERS$;\n      return {\n        id: fixture.id,\n        kickoff_utc: fixture.utc_kickoff,\n        home_team: teamNameById[fixture.home_team_id] || 'Unknown',\n        away_team: teamNameById[fixture.away_team_id] || 'Unknown',\n        broadcaster: ((_SIMPLE_BROADCASTERS$ = SIMPLE_BROADCASTERS.find(b => b.id === broadcastLookup[fixture.id])) === null || _SIMPLE_BROADCASTERS$ === void 0 ? void 0 : _SIMPLE_BROADCASTERS$.name) || undefined\n      };\n    });\n  } catch (error) {\n    console.error('[Supabase] Unexpected error:', error);\n    return [];\n  }\n}\n\n// Save broadcaster assignment (simple)\nexport async function saveBroadcaster(fixtureId, providerId) {\n  try {\n    console.log(`[Supabase] Saving broadcaster for fixture ${fixtureId}: provider ${providerId}`);\n    if (providerId === -1) {\n      // Blackout: remove any broadcaster and mark blackout in localStorage\n      const {\n        error\n      } = await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      if (!blackoutFixtures.includes(fixtureId)) {\n        blackoutFixtures.push(fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n      }\n      console.log(`[Supabase] Set blackout for fixture ${fixtureId}`);\n    } else if (!providerId) {\n      // Remove broadcaster and clear blackout flag\n      const {\n        error\n      } = await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter(id => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Removed broadcaster for fixture ${fixtureId}`);\n    } else {\n      // Add/update broadcaster and clear blackout flag\n      // First delete any existing broadcasts for this fixture to avoid conflicts\n      await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n\n      // Then insert the new broadcast\n      const {\n        error\n      } = await supabase.from('broadcasts').insert({\n        fixture_id: fixtureId,\n        provider_id: providerId\n      });\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter(id => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Saved broadcaster for fixture ${fixtureId}`);\n    }\n  } catch (error) {\n    console.error(`[Supabase] Error saving broadcaster:`, error);\n    throw error;\n  }\n}","map":{"version":3,"names":["supabase","SIMPLE_BROADCASTERS","id","name","getSimpleFixtures","console","log","now","Date","seasonYear","getUTCMonth","getUTCFullYear","seasonStartIso","data","fixtures","error","from","select","gte","order","ascending","length","warn","teamIds","Array","Set","map","f","home_team_id","away_team_id","filter","Boolean","teamNameById","teams","teamError","in","forEach","t","fixtureIds","broadcasts","broadcastLookup","b","fixture_id","provider_id","fixture","_SIMPLE_BROADCASTERS$","kickoff_utc","utc_kickoff","home_team","away_team","broadcaster","find","undefined","saveBroadcaster","fixtureId","providerId","delete","eq","blackoutFixtures","JSON","parse","localStorage","getItem","includes","push","setItem","stringify","updated","insert"],"sources":["/Users/p/Documents/pl_tv_mvp_spa/react-version/src/services/supabase-simple.ts"],"sourcesContent":["import { supabase } from './supabase';\n\n// Simple, minimal types\nexport interface SimpleFixture {\n  id: number;\n  kickoff_utc: string;\n  home_team: string;\n  away_team: string;\n  broadcaster?: string;\n  matchweek?: number;\n}\n\n// Only Sky Sports and TNT Sports for simplicity\nexport const SIMPLE_BROADCASTERS = [\n  { id: 1, name: 'Sky Sports' },\n  { id: 2, name: 'TNT Sports' }\n];\n\n// Get fixtures with basic team info using simple JOINs\nexport async function getSimpleFixtures(): Promise<SimpleFixture[]> {\n  try {\n    console.log('[Supabase] Loading full season fixtures (no JOINs)...');\n\n    // Step 1: Load fixture basics only\n    // Use a dynamic season start (Aug 1 of current season year)\n    const now = new Date();\n    const seasonYear = now.getUTCMonth() >= 6 ? now.getUTCFullYear() : now.getUTCFullYear() - 1;\n    const seasonStartIso = `${seasonYear}-08-01T00:00:00.000Z`;\n\n    const { data: fixtures, error } = await supabase\n      .from('fixtures_with_teams')\n      .select('id, utc_kickoff, home_team_id, away_team_id, home_team, away_team, matchday')\n      .gte('utc_kickoff', seasonStartIso)\n      .order('utc_kickoff', { ascending: true });\n\n    if (error) {\n      console.error('[Supabase] Error loading fixtures:', error);\n      throw error;\n    }\n    if (!fixtures || fixtures.length === 0) {\n      console.warn('[Supabase] No fixtures returned');\n      return [];\n    }\n\n    // Step 2: Load team names in one query\n    const teamIds = Array.from(\n      new Set([\n        ...fixtures.map((f: any) => f.home_team_id),\n        ...fixtures.map((f: any) => f.away_team_id),\n      ].filter(Boolean))\n    );\n\n    let teamNameById: Record<number, string> = {};\n    if (teamIds.length > 0) {\n      const { data: teams, error: teamError } = await supabase\n        .from('teams')\n        .select('id, name')\n        .in('id', teamIds);\n      if (teamError) {\n        console.warn('[Supabase] Error loading teams:', teamError);\n      } else {\n        (teams || []).forEach((t: any) => {\n          teamNameById[t.id] = t.name;\n        });\n      }\n    }\n\n    // Step 3: Load broadcasts for these fixtures\n    const fixtureIds = fixtures.map((f: any) => f.id);\n    const { data: broadcasts } = await supabase\n      .from('broadcasts')\n      .select('fixture_id, provider_id')\n      .in('fixture_id', fixtureIds);\n\n    const broadcastLookup: Record<number, number> = {};\n    (broadcasts || []).forEach((b: any) => {\n      broadcastLookup[b.fixture_id] = b.provider_id;\n    });\n\n    // Step 4: Map to simple format\n    return fixtures.map((fixture: any) => ({\n      id: fixture.id,\n      kickoff_utc: fixture.utc_kickoff,\n      home_team: teamNameById[fixture.home_team_id] || 'Unknown',\n      away_team: teamNameById[fixture.away_team_id] || 'Unknown',\n      broadcaster: SIMPLE_BROADCASTERS.find(b => b.id === broadcastLookup[fixture.id])?.name || undefined,\n    }));\n  } catch (error) {\n    console.error('[Supabase] Unexpected error:', error);\n    return [];\n  }\n}\n\n// Save broadcaster assignment (simple)\nexport async function saveBroadcaster(fixtureId: number, providerId: number | null): Promise<void> {\n  try {\n    console.log(`[Supabase] Saving broadcaster for fixture ${fixtureId}: provider ${providerId}`);\n    \n    if (providerId === -1) {\n      // Blackout: remove any broadcaster and mark blackout in localStorage\n      const { error } = await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n      if (error) throw error;\n\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      if (!blackoutFixtures.includes(fixtureId)) {\n        blackoutFixtures.push(fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n      }\n      console.log(`[Supabase] Set blackout for fixture ${fixtureId}`);\n\n    } else if (!providerId) {\n      // Remove broadcaster and clear blackout flag\n      const { error } = await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n        \n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter((id: number) => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Removed broadcaster for fixture ${fixtureId}`);\n    } else {\n      // Add/update broadcaster and clear blackout flag\n      // First delete any existing broadcasts for this fixture to avoid conflicts\n      await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n\n      // Then insert the new broadcast\n      const { error } = await supabase\n        .from('broadcasts')\n        .insert({\n          fixture_id: fixtureId,\n          provider_id: providerId\n        });\n        \n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter((id: number) => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Saved broadcaster for fixture ${fixtureId}`);\n    }\n  } catch (error) {\n    console.error(`[Supabase] Error saving broadcaster:`, error);\n    throw error;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}