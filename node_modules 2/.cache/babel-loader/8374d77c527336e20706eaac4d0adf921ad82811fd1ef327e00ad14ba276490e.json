{"ast":null,"code":"import { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = 'https://nkfuzkrazehjivzmdrvt.supabase.co';\nconst supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5rZnV6a3JhemVoaml2em1kcnZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcyNjI5MzAsImV4cCI6MjA3MjgzODkzMH0.CNW1EUtcC4JWfDy-WzOIVDfv7rnXzsz1qqQyRTZVyXU';\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\nfunction mapFixtureRow(row, providersByFixture = {}) {\n  var _row$matchday, _row$venue;\n  const kickoffIso = row.utc_kickoff;\n  const mw = (_row$matchday = row.matchday) !== null && _row$matchday !== void 0 ? _row$matchday : null;\n  const home = {\n    id: row.home_team_id,\n    name: row.home_name,\n    slug: row.home_slug,\n    crest: row.home_crest || null\n  };\n  const away = {\n    id: row.away_team_id,\n    name: row.away_name,\n    slug: row.away_slug,\n    crest: row.away_crest || null\n  };\n  const providers = providersByFixture[row.id] || [];\n\n  // Check blackout status from localStorage (matching original SPA logic)\n  const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n  const isBlackout = blackoutFixtures.includes(row.id);\n  return {\n    id: row.id,\n    sport: 'football',\n    competition: 'premier-league',\n    matchweek: mw,\n    kickoff_utc: kickoffIso,\n    venue: (_row$venue = row.venue) !== null && _row$venue !== void 0 ? _row$venue : null,\n    home,\n    away,\n    providers_uk: providers,\n    blackout: {\n      is_blackout: isBlackout,\n      reason: isBlackout ? 'No UK broadcaster announced' : null\n    },\n    status: row.status || 'scheduled'\n  };\n}\nasync function getBroadcastsForFixtures(ids) {\n  try {\n    if (!ids || !ids.length) return [];\n    const {\n      data,\n      error\n    } = await supabase.from('broadcasts').select('fixture_id,provider_id').in('fixture_id', ids);\n    if (error) {\n      console.warn('[Supabase] getBroadcastsForFixtures error', error);\n      return [];\n    }\n    return data || [];\n  } catch (e) {\n    console.warn('[Supabase] getBroadcastsForFixtures error', e);\n    return [];\n  }\n}\nasync function getProvidersByIds(ids = []) {\n  try {\n    let query = supabase.from('providers').select('id,slug,display_name,type,url').order('display_name', {\n      ascending: true\n    });\n    if (ids.length > 0) {\n      query = query.in('id', ids);\n    }\n    const {\n      data: rows,\n      error\n    } = await query;\n    if (error) {\n      console.warn('[Supabase] getProvidersByIds error', error);\n      return [];\n    }\n    return (rows || []).map(p => ({\n      id: p.slug || String(p.id),\n      name: p.display_name || p.name || 'Unknown',\n      type: p.type || 'unknown',\n      href: p.url || undefined,\n      status: 'confirmed'\n    }));\n  } catch (e) {\n    console.warn('[Supabase] getProvidersByIds error', e);\n    return [];\n  }\n}\nexport async function getFixtures(params = {}) {\n  try {\n    const {\n      teamSlug,\n      dateFrom,\n      dateTo,\n      limit = 100,\n      order = 'asc',\n      competitionId\n    } = params;\n    let query = supabase.from('fixtures_with_teams').select(`\n        id,matchday,utc_kickoff,venue,status,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `).order('utc_kickoff', {\n      ascending: order === 'asc'\n    }).limit(limit);\n    if (dateFrom) {\n      query = query.gte('utc_kickoff', dateFrom);\n    }\n    if (dateTo) {\n      query = query.lte('utc_kickoff', dateTo);\n    }\n    if (competitionId) {\n      query = query.eq('competition_id', competitionId);\n    }\n    const {\n      data: rows,\n      error\n    } = await query;\n    if (error) {\n      console.warn('[Supabase] getFixtures error', error);\n      return [];\n    }\n    if (!rows || !rows.length) return [];\n\n    // Enrich providers in a second step\n    const ids = rows.map(r => r.id).filter(Boolean);\n    let providersByFixture = {};\n    if (ids.length) {\n      const bcasts = await getBroadcastsForFixtures(ids);\n      const providerIds = Array.from(new Set(bcasts.map(b => b.provider_id).filter(Boolean)));\n      const provs = providerIds.length ? await getProvidersByIds(providerIds) : [];\n      const byPk = Object.fromEntries(provs.map(p => [p.id, p]));\n      for (const b of bcasts) {\n        const fId = b.fixture_id;\n        const p = byPk[String(b.provider_id)];\n        const entry = p ? {\n          ...p\n        } : null;\n        if (!providersByFixture[fId]) providersByFixture[fId] = [];\n        if (entry) providersByFixture[fId].push(entry);\n      }\n    }\n    let mapped = rows.map(r => mapFixtureRow(r, providersByFixture));\n\n    // Apply team filter if specified\n    if (teamSlug) {\n      mapped = mapped.filter(fx => fx.home.slug === teamSlug || fx.away.slug === teamSlug);\n    }\n\n    // Apply filtering logic to exclude test fixtures (IDs <= 30)\n    // This matches the current SPA's filtering logic\n    mapped = mapped.filter(f => f.id && f.id > 30);\n    return mapped;\n  } catch (e) {\n    console.warn('[Supabase] getFixtures error', e);\n    return [];\n  }\n}\nexport async function getFixtureById(id) {\n  try {\n    if (!id) return undefined;\n    const {\n      data: rows,\n      error\n    } = await supabase.from('fixtures_with_teams').select(`\n        id,matchday,utc_kickoff,venue,status,blackout,blackout_reason,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `).eq('id', id).limit(1);\n    if (error) {\n      console.warn('[Supabase] getFixtureById error', error);\n      return undefined;\n    }\n    const row = rows === null || rows === void 0 ? void 0 : rows[0];\n    if (!row) return undefined;\n    const bcasts = await getBroadcastsForFixtures([row.id]);\n    const providerIds = Array.from(new Set(bcasts.map(b => b.provider_id).filter(Boolean)));\n    const provs = providerIds.length ? await getProvidersByIds(providerIds) : [];\n    const byPk = Object.fromEntries(provs.map(p => [p.id, p]));\n    const providersByFixture = {};\n    providersByFixture[row.id] = bcasts.map(b => {\n      const p = byPk[String(b.provider_id)];\n      return p ? {\n        ...p\n      } : null;\n    }).filter(Boolean);\n    return mapFixtureRow(row, providersByFixture);\n  } catch (e) {\n    console.warn('[Supabase] getFixtureById error', e);\n    return undefined;\n  }\n}\n\n// Admin API functions\n\nexport const BROADCASTERS = [{\n  id: 1,\n  name: 'Sky Sports',\n  type: 'tv'\n}, {\n  id: 2,\n  name: 'TNT Sports',\n  type: 'tv'\n}, {\n  id: 3,\n  name: 'BBC Sport',\n  type: 'tv'\n}, {\n  id: 4,\n  name: 'Amazon Prime Video',\n  type: 'streaming'\n}, {\n  id: -1,\n  name: 'ðŸš« Blackout (No TV)',\n  type: 'blackout'\n}];\nexport async function getAdminFixtures(competitionId = 1) {\n  try {\n    // Get fixtures from current season\n    const currentSeasonStart = '2024-08-01T00:00:00.000Z';\n    const {\n      data: rows,\n      error\n    } = await supabase.from('fixtures_with_teams').select(`\n        id,matchday,utc_kickoff,venue,status,blackout,blackout_reason,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `).eq('competition_id', competitionId).gte('utc_kickoff', currentSeasonStart).order('utc_kickoff', {\n      ascending: true\n    });\n    if (error) {\n      console.warn('[Supabase] getAdminFixtures error', error);\n      return [];\n    }\n    if (!rows || !rows.length) return [];\n\n    // Apply same filtering as main app (exclude test fixtures)\n    const validRows = rows.filter(r => r.id && r.id > 30);\n\n    // Get all broadcasts for these fixtures\n    const fixtureIds = validRows.map(r => r.id);\n    const {\n      data: broadcasts,\n      error: broadcastError\n    } = await supabase.from('broadcasts').select('fixture_id,provider_id').in('fixture_id', fixtureIds);\n    if (broadcastError) {\n      console.warn('[Supabase] Error loading broadcasts:', broadcastError);\n    }\n\n    // Create broadcast lookup\n    const broadcastLookup = {};\n    (broadcasts || []).forEach(b => {\n      broadcastLookup[b.fixture_id] = b;\n    });\n\n    // Map fixtures with broadcast info\n    const adminFixtures = validRows.map(row => {\n      var _BROADCASTERS$find;\n      const broadcast = broadcastLookup[row.id] || null;\n      const fixture = mapFixtureRow(row);\n      return {\n        ...fixture,\n        broadcast: broadcast ? {\n          provider_id: broadcast.provider_id,\n          provider_display_name: ((_BROADCASTERS$find = BROADCASTERS.find(b => b.id === broadcast.provider_id)) === null || _BROADCASTERS$find === void 0 ? void 0 : _BROADCASTERS$find.name) || 'Unknown'\n        } : null\n      };\n    });\n    return adminFixtures;\n  } catch (e) {\n    console.warn('[Supabase] getAdminFixtures error', e);\n    return [];\n  }\n}\nexport async function saveBroadcast(fixtureId, providerId) {\n  try {\n    if (providerId === '' || providerId === '0' || providerId === '-1' || providerId === null) {\n      // Delete existing broadcast record\n      const {\n        error\n      } = await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n      if (error) {\n        throw error;\n      }\n\n      // Handle blackout localStorage logic\n      if (providerId === '-1') {\n        const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n        if (!blackoutFixtures.includes(fixtureId)) {\n          blackoutFixtures.push(fixtureId);\n          localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n        }\n      } else {\n        // Remove from blackout list if setting to empty\n        const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n        const updatedBlackout = blackoutFixtures.filter(id => id !== fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));\n      }\n    } else {\n      // Add/update broadcaster - remove from blackout list first\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updatedBlackout = blackoutFixtures.filter(id => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));\n      const broadcastData = {\n        fixture_id: fixtureId,\n        provider_id: parseInt(String(providerId))\n      };\n\n      // Upsert the broadcast record\n      const {\n        error\n      } = await supabase.from('broadcasts').upsert(broadcastData);\n      if (error) {\n        throw error;\n      }\n    }\n  } catch (e) {\n    console.error('[Supabase] saveBroadcast error', e);\n    throw e;\n  }\n}\n\n// Blackout helper functions\nexport function isFixtureBlackout(fixtureId) {\n  const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n  return blackoutFixtures.includes(fixtureId);\n}\nexport function isFixtureConfirmed(fixture) {\n  return !!(fixture.broadcast && fixture.broadcast.provider_id && !isFixtureBlackout(fixture.id));\n}\nexport function isFixturePending(fixture) {\n  return !fixture.broadcast && !isFixtureBlackout(fixture.id);\n}","map":{"version":3,"names":["createClient","supabaseUrl","supabaseAnonKey","supabase","mapFixtureRow","row","providersByFixture","_row$matchday","_row$venue","kickoffIso","utc_kickoff","mw","matchday","home","id","home_team_id","name","home_name","slug","home_slug","crest","home_crest","away","away_team_id","away_name","away_slug","away_crest","providers","blackoutFixtures","JSON","parse","localStorage","getItem","isBlackout","includes","sport","competition","matchweek","kickoff_utc","venue","providers_uk","blackout","is_blackout","reason","status","getBroadcastsForFixtures","ids","length","data","error","from","select","in","console","warn","e","getProvidersByIds","query","order","ascending","rows","map","p","String","display_name","type","href","url","undefined","getFixtures","params","teamSlug","dateFrom","dateTo","limit","competitionId","gte","lte","eq","r","filter","Boolean","bcasts","providerIds","Array","Set","b","provider_id","provs","byPk","Object","fromEntries","fId","fixture_id","entry","push","mapped","fx","f","getFixtureById","BROADCASTERS","getAdminFixtures","currentSeasonStart","validRows","fixtureIds","broadcasts","broadcastError","broadcastLookup","forEach","adminFixtures","_BROADCASTERS$find","broadcast","fixture","provider_display_name","find","saveBroadcast","fixtureId","providerId","delete","setItem","stringify","updatedBlackout","broadcastData","parseInt","upsert","isFixtureBlackout","isFixtureConfirmed","isFixturePending"],"sources":["/Users/p/Documents/pl_tv_mvp_spa/react-version/src/services/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport type { Fixture, FixturesApiParams, Provider, Team } from '../types';\n\nconst supabaseUrl = 'https://nkfuzkrazehjivzmdrvt.supabase.co';\nconst supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5rZnV6a3JhemVoaml2em1kcnZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcyNjI5MzAsImV4cCI6MjA3MjgzODkzMH0.CNW1EUtcC4JWfDy-WzOIVDfv7rnXzsz1qqQyRTZVyXU';\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\ninterface FixtureRow {\n  id: number;\n  matchday?: number | null;\n  utc_kickoff: string;\n  venue?: string | null;\n  status?: string;\n  home_team_id: number;\n  home_name: string;\n  home_slug: string;\n  home_crest?: string | null;\n  away_team_id: number;\n  away_name: string;\n  away_slug: string;\n  away_crest?: string | null;\n}\n\ninterface BroadcastRow {\n  fixture_id: number;\n  provider_id: number;\n}\n\ninterface ProviderRow {\n  id: number;\n  slug?: string;\n  display_name?: string;\n  name?: string;\n  type?: string;\n  url?: string;\n}\n\nfunction mapFixtureRow(row: FixtureRow, providersByFixture: Record<number, Provider[]> = {}): Fixture {\n  const kickoffIso = row.utc_kickoff;\n  const mw = row.matchday ?? null;\n  const home: Team = {\n    id: row.home_team_id,\n    name: row.home_name,\n    slug: row.home_slug,\n    crest: row.home_crest || null,\n  };\n  const away: Team = {\n    id: row.away_team_id,\n    name: row.away_name,\n    slug: row.away_slug,\n    crest: row.away_crest || null,\n  };\n  const providers = providersByFixture[row.id] || [];\n\n  // Check blackout status from localStorage (matching original SPA logic)\n  const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n  const isBlackout = blackoutFixtures.includes(row.id);\n\n  return {\n    id: row.id,\n    sport: 'football',\n    competition: 'premier-league',\n    matchweek: mw,\n    kickoff_utc: kickoffIso,\n    venue: row.venue ?? null,\n    home,\n    away,\n    providers_uk: providers,\n    blackout: { \n      is_blackout: isBlackout, \n      reason: isBlackout ? 'No UK broadcaster announced' : null \n    },\n    status: row.status || 'scheduled',\n  };\n}\n\nasync function getBroadcastsForFixtures(ids: number[]): Promise<BroadcastRow[]> {\n  try {\n    if (!ids || !ids.length) return [];\n    \n    const { data, error } = await supabase\n      .from('broadcasts')\n      .select('fixture_id,provider_id')\n      .in('fixture_id', ids);\n      \n    if (error) {\n      console.warn('[Supabase] getBroadcastsForFixtures error', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (e) {\n    console.warn('[Supabase] getBroadcastsForFixtures error', e);\n    return [];\n  }\n}\n\nasync function getProvidersByIds(ids: number[] = []): Promise<Provider[]> {\n  try {\n    let query = supabase\n      .from('providers')\n      .select('id,slug,display_name,type,url')\n      .order('display_name', { ascending: true });\n      \n    if (ids.length > 0) {\n      query = query.in('id', ids);\n    }\n    \n    const { data: rows, error } = await query;\n    \n    if (error) {\n      console.warn('[Supabase] getProvidersByIds error', error);\n      return [];\n    }\n    \n    return (rows || []).map((p: ProviderRow) => ({\n      id: p.slug || String(p.id),\n      name: p.display_name || p.name || 'Unknown',\n      type: p.type || 'unknown',\n      href: p.url || undefined,\n      status: 'confirmed',\n    }));\n  } catch (e) {\n    console.warn('[Supabase] getProvidersByIds error', e);\n    return [];\n  }\n}\n\nexport async function getFixtures(params: FixturesApiParams = {}): Promise<Fixture[]> {\n  try {\n    const {\n      teamSlug,\n      dateFrom,\n      dateTo,\n      limit = 100,\n      order = 'asc',\n      competitionId\n    } = params;\n\n    let query = supabase\n      .from('fixtures_with_teams')\n      .select(`\n        id,matchday,utc_kickoff,venue,status,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `)\n      .order('utc_kickoff', { ascending: order === 'asc' })\n      .limit(limit);\n      \n    if (dateFrom) {\n      query = query.gte('utc_kickoff', dateFrom);\n    }\n    if (dateTo) {\n      query = query.lte('utc_kickoff', dateTo);\n    }\n    if (competitionId) {\n      query = query.eq('competition_id', competitionId);\n    }\n\n    const { data: rows, error } = await query;\n    \n    if (error) {\n      console.warn('[Supabase] getFixtures error', error);\n      return [];\n    }\n    \n    if (!rows || !rows.length) return [];\n\n    // Enrich providers in a second step\n    const ids = rows.map(r => r.id).filter(Boolean);\n    let providersByFixture: Record<number, Provider[]> = {};\n    \n    if (ids.length) {\n      const bcasts = await getBroadcastsForFixtures(ids);\n      const providerIds = Array.from(new Set(bcasts.map(b => b.provider_id).filter(Boolean)));\n      const provs = providerIds.length ? await getProvidersByIds(providerIds) : [];\n      const byPk = Object.fromEntries(provs.map(p => [p.id, p]));\n      \n      for (const b of bcasts) {\n        const fId = b.fixture_id;\n        const p = byPk[String(b.provider_id)];\n        const entry = p ? { ...p } : null;\n        if (!providersByFixture[fId]) providersByFixture[fId] = [];\n        if (entry) providersByFixture[fId].push(entry);\n      }\n    }\n    \n    let mapped = rows.map(r => mapFixtureRow(r, providersByFixture));\n\n    // Apply team filter if specified\n    if (teamSlug) {\n      mapped = mapped.filter(fx => fx.home.slug === teamSlug || fx.away.slug === teamSlug);\n    }\n    \n    // Apply filtering logic to exclude test fixtures (IDs <= 30)\n    // This matches the current SPA's filtering logic\n    mapped = mapped.filter(f => f.id && f.id > 30);\n    \n    return mapped;\n  } catch (e) {\n    console.warn('[Supabase] getFixtures error', e);\n    return [];\n  }\n}\n\nexport async function getFixtureById(id: number): Promise<Fixture | undefined> {\n  try {\n    if (!id) return undefined;\n    \n    const { data: rows, error } = await supabase\n      .from('fixtures_with_teams')\n      .select(`\n        id,matchday,utc_kickoff,venue,status,blackout,blackout_reason,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `)\n      .eq('id', id)\n      .limit(1);\n      \n    if (error) {\n      console.warn('[Supabase] getFixtureById error', error);\n      return undefined;\n    }\n    \n    const row = rows?.[0];\n    if (!row) return undefined;\n    \n    const bcasts = await getBroadcastsForFixtures([row.id]);\n    const providerIds = Array.from(new Set(bcasts.map(b => b.provider_id).filter(Boolean)));\n    const provs = providerIds.length ? await getProvidersByIds(providerIds) : [];\n    const byPk = Object.fromEntries(provs.map(p => [p.id, p]));\n    \n    const providersByFixture: Record<number, Provider[]> = {};\n    providersByFixture[row.id] = bcasts.map(b => {\n      const p = byPk[String(b.provider_id)];\n      return p ? { ...p } : null;\n    }).filter(Boolean) as Provider[];\n    \n    return mapFixtureRow(row, providersByFixture);\n  } catch (e) {\n    console.warn('[Supabase] getFixtureById error', e);\n    return undefined;\n  }\n}\n\n// Admin API functions\n\nexport interface AdminFixture extends Fixture {\n  broadcast?: {\n    provider_id: number;\n    provider_display_name?: string;\n    channel?: string;\n  } | null;\n}\n\nexport const BROADCASTERS = [\n  { id: 1, name: 'Sky Sports', type: 'tv' },\n  { id: 2, name: 'TNT Sports', type: 'tv' },\n  { id: 3, name: 'BBC Sport', type: 'tv' },\n  { id: 4, name: 'Amazon Prime Video', type: 'streaming' },\n  { id: -1, name: 'ðŸš« Blackout (No TV)', type: 'blackout' }\n];\n\nexport async function getAdminFixtures(competitionId: number = 1): Promise<AdminFixture[]> {\n  try {\n    // Get fixtures from current season\n    const currentSeasonStart = '2024-08-01T00:00:00.000Z';\n    \n    const { data: rows, error } = await supabase\n      .from('fixtures_with_teams')\n      .select(`\n        id,matchday,utc_kickoff,venue,status,blackout,blackout_reason,\n        home_team_id,home_name,home_slug,home_crest,\n        away_team_id,away_name,away_slug,away_crest\n      `)\n      .eq('competition_id', competitionId)\n      .gte('utc_kickoff', currentSeasonStart)\n      .order('utc_kickoff', { ascending: true });\n      \n    if (error) {\n      console.warn('[Supabase] getAdminFixtures error', error);\n      return [];\n    }\n    \n    if (!rows || !rows.length) return [];\n\n    // Apply same filtering as main app (exclude test fixtures)\n    const validRows = rows.filter(r => r.id && r.id > 30);\n    \n    // Get all broadcasts for these fixtures\n    const fixtureIds = validRows.map(r => r.id);\n    const { data: broadcasts, error: broadcastError } = await supabase\n      .from('broadcasts')\n      .select('fixture_id,provider_id')\n      .in('fixture_id', fixtureIds);\n      \n    if (broadcastError) {\n      console.warn('[Supabase] Error loading broadcasts:', broadcastError);\n    }\n    \n    // Create broadcast lookup\n    const broadcastLookup: Record<number, BroadcastRow> = {};\n    (broadcasts || []).forEach(b => {\n      broadcastLookup[b.fixture_id] = b;\n    });\n    \n    // Map fixtures with broadcast info\n    const adminFixtures: AdminFixture[] = validRows.map(row => {\n      const broadcast = broadcastLookup[row.id] || null;\n      const fixture = mapFixtureRow(row);\n      \n      return {\n        ...fixture,\n        broadcast: broadcast ? {\n          provider_id: broadcast.provider_id,\n          provider_display_name: BROADCASTERS.find(b => b.id === broadcast.provider_id)?.name || 'Unknown'\n        } : null\n      };\n    });\n    \n    return adminFixtures;\n  } catch (e) {\n    console.warn('[Supabase] getAdminFixtures error', e);\n    return [];\n  }\n}\n\nexport async function saveBroadcast(fixtureId: number, providerId: number | string | null): Promise<void> {\n  try {\n    if (providerId === '' || providerId === '0' || providerId === '-1' || providerId === null) {\n      // Delete existing broadcast record\n      const { error } = await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n        \n      if (error) {\n        throw error;\n      }\n      \n      // Handle blackout localStorage logic\n      if (providerId === '-1') {\n        const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n        if (!blackoutFixtures.includes(fixtureId)) {\n          blackoutFixtures.push(fixtureId);\n          localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n        }\n      } else {\n        // Remove from blackout list if setting to empty\n        const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n        const updatedBlackout = blackoutFixtures.filter((id: number) => id !== fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));\n      }\n    } else {\n      // Add/update broadcaster - remove from blackout list first\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updatedBlackout = blackoutFixtures.filter((id: number) => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updatedBlackout));\n      \n      const broadcastData = {\n        fixture_id: fixtureId,\n        provider_id: parseInt(String(providerId))\n      };\n      \n      // Upsert the broadcast record\n      const { error } = await supabase\n        .from('broadcasts')\n        .upsert(broadcastData);\n        \n      if (error) {\n        throw error;\n      }\n    }\n  } catch (e) {\n    console.error('[Supabase] saveBroadcast error', e);\n    throw e;\n  }\n}\n\n// Blackout helper functions\nexport function isFixtureBlackout(fixtureId: number): boolean {\n  const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n  return blackoutFixtures.includes(fixtureId);\n}\n\nexport function isFixtureConfirmed(fixture: AdminFixture): boolean {\n  return !!(fixture.broadcast && fixture.broadcast.provider_id && !isFixtureBlackout(fixture.id));\n}\n\nexport function isFixturePending(fixture: AdminFixture): boolean {\n  return !fixture.broadcast && !isFixtureBlackout(fixture.id);\n}"],"mappings":"AAAA,SAASA,YAAY,QAAQ,uBAAuB;AAGpD,MAAMC,WAAW,GAAG,0CAA0C;AAC9D,MAAMC,eAAe,GAAG,kNAAkN;AAE1O,OAAO,MAAMC,QAAQ,GAAGH,YAAY,CAACC,WAAW,EAAEC,eAAe,CAAC;AAgClE,SAASE,aAAaA,CAACC,GAAe,EAAEC,kBAA8C,GAAG,CAAC,CAAC,EAAW;EAAA,IAAAC,aAAA,EAAAC,UAAA;EACpG,MAAMC,UAAU,GAAGJ,GAAG,CAACK,WAAW;EAClC,MAAMC,EAAE,IAAAJ,aAAA,GAAGF,GAAG,CAACO,QAAQ,cAAAL,aAAA,cAAAA,aAAA,GAAI,IAAI;EAC/B,MAAMM,IAAU,GAAG;IACjBC,EAAE,EAAET,GAAG,CAACU,YAAY;IACpBC,IAAI,EAAEX,GAAG,CAACY,SAAS;IACnBC,IAAI,EAAEb,GAAG,CAACc,SAAS;IACnBC,KAAK,EAAEf,GAAG,CAACgB,UAAU,IAAI;EAC3B,CAAC;EACD,MAAMC,IAAU,GAAG;IACjBR,EAAE,EAAET,GAAG,CAACkB,YAAY;IACpBP,IAAI,EAAEX,GAAG,CAACmB,SAAS;IACnBN,IAAI,EAAEb,GAAG,CAACoB,SAAS;IACnBL,KAAK,EAAEf,GAAG,CAACqB,UAAU,IAAI;EAC3B,CAAC;EACD,MAAMC,SAAS,GAAGrB,kBAAkB,CAACD,GAAG,CAACS,EAAE,CAAC,IAAI,EAAE;;EAElD;EACA,MAAMc,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,IAAI,CAAC;EACrF,MAAMC,UAAU,GAAGL,gBAAgB,CAACM,QAAQ,CAAC7B,GAAG,CAACS,EAAE,CAAC;EAEpD,OAAO;IACLA,EAAE,EAAET,GAAG,CAACS,EAAE;IACVqB,KAAK,EAAE,UAAU;IACjBC,WAAW,EAAE,gBAAgB;IAC7BC,SAAS,EAAE1B,EAAE;IACb2B,WAAW,EAAE7B,UAAU;IACvB8B,KAAK,GAAA/B,UAAA,GAAEH,GAAG,CAACkC,KAAK,cAAA/B,UAAA,cAAAA,UAAA,GAAI,IAAI;IACxBK,IAAI;IACJS,IAAI;IACJkB,YAAY,EAAEb,SAAS;IACvBc,QAAQ,EAAE;MACRC,WAAW,EAAET,UAAU;MACvBU,MAAM,EAAEV,UAAU,GAAG,6BAA6B,GAAG;IACvD,CAAC;IACDW,MAAM,EAAEvC,GAAG,CAACuC,MAAM,IAAI;EACxB,CAAC;AACH;AAEA,eAAeC,wBAAwBA,CAACC,GAAa,EAA2B;EAC9E,IAAI;IACF,IAAI,CAACA,GAAG,IAAI,CAACA,GAAG,CAACC,MAAM,EAAE,OAAO,EAAE;IAElC,MAAM;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAG,MAAM9C,QAAQ,CACnC+C,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,wBAAwB,CAAC,CAChCC,EAAE,CAAC,YAAY,EAAEN,GAAG,CAAC;IAExB,IAAIG,KAAK,EAAE;MACTI,OAAO,CAACC,IAAI,CAAC,2CAA2C,EAAEL,KAAK,CAAC;MAChE,OAAO,EAAE;IACX;IAEA,OAAOD,IAAI,IAAI,EAAE;EACnB,CAAC,CAAC,OAAOO,CAAC,EAAE;IACVF,OAAO,CAACC,IAAI,CAAC,2CAA2C,EAAEC,CAAC,CAAC;IAC5D,OAAO,EAAE;EACX;AACF;AAEA,eAAeC,iBAAiBA,CAACV,GAAa,GAAG,EAAE,EAAuB;EACxE,IAAI;IACF,IAAIW,KAAK,GAAGtD,QAAQ,CACjB+C,IAAI,CAAC,WAAW,CAAC,CACjBC,MAAM,CAAC,+BAA+B,CAAC,CACvCO,KAAK,CAAC,cAAc,EAAE;MAAEC,SAAS,EAAE;IAAK,CAAC,CAAC;IAE7C,IAAIb,GAAG,CAACC,MAAM,GAAG,CAAC,EAAE;MAClBU,KAAK,GAAGA,KAAK,CAACL,EAAE,CAAC,IAAI,EAAEN,GAAG,CAAC;IAC7B;IAEA,MAAM;MAAEE,IAAI,EAAEY,IAAI;MAAEX;IAAM,CAAC,GAAG,MAAMQ,KAAK;IAEzC,IAAIR,KAAK,EAAE;MACTI,OAAO,CAACC,IAAI,CAAC,oCAAoC,EAAEL,KAAK,CAAC;MACzD,OAAO,EAAE;IACX;IAEA,OAAO,CAACW,IAAI,IAAI,EAAE,EAAEC,GAAG,CAAEC,CAAc,KAAM;MAC3ChD,EAAE,EAAEgD,CAAC,CAAC5C,IAAI,IAAI6C,MAAM,CAACD,CAAC,CAAChD,EAAE,CAAC;MAC1BE,IAAI,EAAE8C,CAAC,CAACE,YAAY,IAAIF,CAAC,CAAC9C,IAAI,IAAI,SAAS;MAC3CiD,IAAI,EAAEH,CAAC,CAACG,IAAI,IAAI,SAAS;MACzBC,IAAI,EAAEJ,CAAC,CAACK,GAAG,IAAIC,SAAS;MACxBxB,MAAM,EAAE;IACV,CAAC,CAAC,CAAC;EACL,CAAC,CAAC,OAAOW,CAAC,EAAE;IACVF,OAAO,CAACC,IAAI,CAAC,oCAAoC,EAAEC,CAAC,CAAC;IACrD,OAAO,EAAE;EACX;AACF;AAEA,OAAO,eAAec,WAAWA,CAACC,MAAyB,GAAG,CAAC,CAAC,EAAsB;EACpF,IAAI;IACF,MAAM;MACJC,QAAQ;MACRC,QAAQ;MACRC,MAAM;MACNC,KAAK,GAAG,GAAG;MACXhB,KAAK,GAAG,KAAK;MACbiB;IACF,CAAC,GAAGL,MAAM;IAEV,IAAIb,KAAK,GAAGtD,QAAQ,CACjB+C,IAAI,CAAC,qBAAqB,CAAC,CAC3BC,MAAM,CAAC;AACd;AACA;AACA;AACA,OAAO,CAAC,CACDO,KAAK,CAAC,aAAa,EAAE;MAAEC,SAAS,EAAED,KAAK,KAAK;IAAM,CAAC,CAAC,CACpDgB,KAAK,CAACA,KAAK,CAAC;IAEf,IAAIF,QAAQ,EAAE;MACZf,KAAK,GAAGA,KAAK,CAACmB,GAAG,CAAC,aAAa,EAAEJ,QAAQ,CAAC;IAC5C;IACA,IAAIC,MAAM,EAAE;MACVhB,KAAK,GAAGA,KAAK,CAACoB,GAAG,CAAC,aAAa,EAAEJ,MAAM,CAAC;IAC1C;IACA,IAAIE,aAAa,EAAE;MACjBlB,KAAK,GAAGA,KAAK,CAACqB,EAAE,CAAC,gBAAgB,EAAEH,aAAa,CAAC;IACnD;IAEA,MAAM;MAAE3B,IAAI,EAAEY,IAAI;MAAEX;IAAM,CAAC,GAAG,MAAMQ,KAAK;IAEzC,IAAIR,KAAK,EAAE;MACTI,OAAO,CAACC,IAAI,CAAC,8BAA8B,EAAEL,KAAK,CAAC;MACnD,OAAO,EAAE;IACX;IAEA,IAAI,CAACW,IAAI,IAAI,CAACA,IAAI,CAACb,MAAM,EAAE,OAAO,EAAE;;IAEpC;IACA,MAAMD,GAAG,GAAGc,IAAI,CAACC,GAAG,CAACkB,CAAC,IAAIA,CAAC,CAACjE,EAAE,CAAC,CAACkE,MAAM,CAACC,OAAO,CAAC;IAC/C,IAAI3E,kBAA8C,GAAG,CAAC,CAAC;IAEvD,IAAIwC,GAAG,CAACC,MAAM,EAAE;MACd,MAAMmC,MAAM,GAAG,MAAMrC,wBAAwB,CAACC,GAAG,CAAC;MAClD,MAAMqC,WAAW,GAAGC,KAAK,CAAClC,IAAI,CAAC,IAAImC,GAAG,CAACH,MAAM,CAACrB,GAAG,CAACyB,CAAC,IAAIA,CAAC,CAACC,WAAW,CAAC,CAACP,MAAM,CAACC,OAAO,CAAC,CAAC,CAAC;MACvF,MAAMO,KAAK,GAAGL,WAAW,CAACpC,MAAM,GAAG,MAAMS,iBAAiB,CAAC2B,WAAW,CAAC,GAAG,EAAE;MAC5E,MAAMM,IAAI,GAAGC,MAAM,CAACC,WAAW,CAACH,KAAK,CAAC3B,GAAG,CAACC,CAAC,IAAI,CAACA,CAAC,CAAChD,EAAE,EAAEgD,CAAC,CAAC,CAAC,CAAC;MAE1D,KAAK,MAAMwB,CAAC,IAAIJ,MAAM,EAAE;QACtB,MAAMU,GAAG,GAAGN,CAAC,CAACO,UAAU;QACxB,MAAM/B,CAAC,GAAG2B,IAAI,CAAC1B,MAAM,CAACuB,CAAC,CAACC,WAAW,CAAC,CAAC;QACrC,MAAMO,KAAK,GAAGhC,CAAC,GAAG;UAAE,GAAGA;QAAE,CAAC,GAAG,IAAI;QACjC,IAAI,CAACxD,kBAAkB,CAACsF,GAAG,CAAC,EAAEtF,kBAAkB,CAACsF,GAAG,CAAC,GAAG,EAAE;QAC1D,IAAIE,KAAK,EAAExF,kBAAkB,CAACsF,GAAG,CAAC,CAACG,IAAI,CAACD,KAAK,CAAC;MAChD;IACF;IAEA,IAAIE,MAAM,GAAGpC,IAAI,CAACC,GAAG,CAACkB,CAAC,IAAI3E,aAAa,CAAC2E,CAAC,EAAEzE,kBAAkB,CAAC,CAAC;;IAEhE;IACA,IAAIiE,QAAQ,EAAE;MACZyB,MAAM,GAAGA,MAAM,CAAChB,MAAM,CAACiB,EAAE,IAAIA,EAAE,CAACpF,IAAI,CAACK,IAAI,KAAKqD,QAAQ,IAAI0B,EAAE,CAAC3E,IAAI,CAACJ,IAAI,KAAKqD,QAAQ,CAAC;IACtF;;IAEA;IACA;IACAyB,MAAM,GAAGA,MAAM,CAAChB,MAAM,CAACkB,CAAC,IAAIA,CAAC,CAACpF,EAAE,IAAIoF,CAAC,CAACpF,EAAE,GAAG,EAAE,CAAC;IAE9C,OAAOkF,MAAM;EACf,CAAC,CAAC,OAAOzC,CAAC,EAAE;IACVF,OAAO,CAACC,IAAI,CAAC,8BAA8B,EAAEC,CAAC,CAAC;IAC/C,OAAO,EAAE;EACX;AACF;AAEA,OAAO,eAAe4C,cAAcA,CAACrF,EAAU,EAAgC;EAC7E,IAAI;IACF,IAAI,CAACA,EAAE,EAAE,OAAOsD,SAAS;IAEzB,MAAM;MAAEpB,IAAI,EAAEY,IAAI;MAAEX;IAAM,CAAC,GAAG,MAAM9C,QAAQ,CACzC+C,IAAI,CAAC,qBAAqB,CAAC,CAC3BC,MAAM,CAAC;AACd;AACA;AACA;AACA,OAAO,CAAC,CACD2B,EAAE,CAAC,IAAI,EAAEhE,EAAE,CAAC,CACZ4D,KAAK,CAAC,CAAC,CAAC;IAEX,IAAIzB,KAAK,EAAE;MACTI,OAAO,CAACC,IAAI,CAAC,iCAAiC,EAAEL,KAAK,CAAC;MACtD,OAAOmB,SAAS;IAClB;IAEA,MAAM/D,GAAG,GAAGuD,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAG,CAAC,CAAC;IACrB,IAAI,CAACvD,GAAG,EAAE,OAAO+D,SAAS;IAE1B,MAAMc,MAAM,GAAG,MAAMrC,wBAAwB,CAAC,CAACxC,GAAG,CAACS,EAAE,CAAC,CAAC;IACvD,MAAMqE,WAAW,GAAGC,KAAK,CAAClC,IAAI,CAAC,IAAImC,GAAG,CAACH,MAAM,CAACrB,GAAG,CAACyB,CAAC,IAAIA,CAAC,CAACC,WAAW,CAAC,CAACP,MAAM,CAACC,OAAO,CAAC,CAAC,CAAC;IACvF,MAAMO,KAAK,GAAGL,WAAW,CAACpC,MAAM,GAAG,MAAMS,iBAAiB,CAAC2B,WAAW,CAAC,GAAG,EAAE;IAC5E,MAAMM,IAAI,GAAGC,MAAM,CAACC,WAAW,CAACH,KAAK,CAAC3B,GAAG,CAACC,CAAC,IAAI,CAACA,CAAC,CAAChD,EAAE,EAAEgD,CAAC,CAAC,CAAC,CAAC;IAE1D,MAAMxD,kBAA8C,GAAG,CAAC,CAAC;IACzDA,kBAAkB,CAACD,GAAG,CAACS,EAAE,CAAC,GAAGoE,MAAM,CAACrB,GAAG,CAACyB,CAAC,IAAI;MAC3C,MAAMxB,CAAC,GAAG2B,IAAI,CAAC1B,MAAM,CAACuB,CAAC,CAACC,WAAW,CAAC,CAAC;MACrC,OAAOzB,CAAC,GAAG;QAAE,GAAGA;MAAE,CAAC,GAAG,IAAI;IAC5B,CAAC,CAAC,CAACkB,MAAM,CAACC,OAAO,CAAe;IAEhC,OAAO7E,aAAa,CAACC,GAAG,EAAEC,kBAAkB,CAAC;EAC/C,CAAC,CAAC,OAAOiD,CAAC,EAAE;IACVF,OAAO,CAACC,IAAI,CAAC,iCAAiC,EAAEC,CAAC,CAAC;IAClD,OAAOa,SAAS;EAClB;AACF;;AAEA;;AAUA,OAAO,MAAMgC,YAAY,GAAG,CAC1B;EAAEtF,EAAE,EAAE,CAAC;EAAEE,IAAI,EAAE,YAAY;EAAEiD,IAAI,EAAE;AAAK,CAAC,EACzC;EAAEnD,EAAE,EAAE,CAAC;EAAEE,IAAI,EAAE,YAAY;EAAEiD,IAAI,EAAE;AAAK,CAAC,EACzC;EAAEnD,EAAE,EAAE,CAAC;EAAEE,IAAI,EAAE,WAAW;EAAEiD,IAAI,EAAE;AAAK,CAAC,EACxC;EAAEnD,EAAE,EAAE,CAAC;EAAEE,IAAI,EAAE,oBAAoB;EAAEiD,IAAI,EAAE;AAAY,CAAC,EACxD;EAAEnD,EAAE,EAAE,CAAC,CAAC;EAAEE,IAAI,EAAE,qBAAqB;EAAEiD,IAAI,EAAE;AAAW,CAAC,CAC1D;AAED,OAAO,eAAeoC,gBAAgBA,CAAC1B,aAAqB,GAAG,CAAC,EAA2B;EACzF,IAAI;IACF;IACA,MAAM2B,kBAAkB,GAAG,0BAA0B;IAErD,MAAM;MAAEtD,IAAI,EAAEY,IAAI;MAAEX;IAAM,CAAC,GAAG,MAAM9C,QAAQ,CACzC+C,IAAI,CAAC,qBAAqB,CAAC,CAC3BC,MAAM,CAAC;AACd;AACA;AACA;AACA,OAAO,CAAC,CACD2B,EAAE,CAAC,gBAAgB,EAAEH,aAAa,CAAC,CACnCC,GAAG,CAAC,aAAa,EAAE0B,kBAAkB,CAAC,CACtC5C,KAAK,CAAC,aAAa,EAAE;MAAEC,SAAS,EAAE;IAAK,CAAC,CAAC;IAE5C,IAAIV,KAAK,EAAE;MACTI,OAAO,CAACC,IAAI,CAAC,mCAAmC,EAAEL,KAAK,CAAC;MACxD,OAAO,EAAE;IACX;IAEA,IAAI,CAACW,IAAI,IAAI,CAACA,IAAI,CAACb,MAAM,EAAE,OAAO,EAAE;;IAEpC;IACA,MAAMwD,SAAS,GAAG3C,IAAI,CAACoB,MAAM,CAACD,CAAC,IAAIA,CAAC,CAACjE,EAAE,IAAIiE,CAAC,CAACjE,EAAE,GAAG,EAAE,CAAC;;IAErD;IACA,MAAM0F,UAAU,GAAGD,SAAS,CAAC1C,GAAG,CAACkB,CAAC,IAAIA,CAAC,CAACjE,EAAE,CAAC;IAC3C,MAAM;MAAEkC,IAAI,EAAEyD,UAAU;MAAExD,KAAK,EAAEyD;IAAe,CAAC,GAAG,MAAMvG,QAAQ,CAC/D+C,IAAI,CAAC,YAAY,CAAC,CAClBC,MAAM,CAAC,wBAAwB,CAAC,CAChCC,EAAE,CAAC,YAAY,EAAEoD,UAAU,CAAC;IAE/B,IAAIE,cAAc,EAAE;MAClBrD,OAAO,CAACC,IAAI,CAAC,sCAAsC,EAAEoD,cAAc,CAAC;IACtE;;IAEA;IACA,MAAMC,eAA6C,GAAG,CAAC,CAAC;IACxD,CAACF,UAAU,IAAI,EAAE,EAAEG,OAAO,CAACtB,CAAC,IAAI;MAC9BqB,eAAe,CAACrB,CAAC,CAACO,UAAU,CAAC,GAAGP,CAAC;IACnC,CAAC,CAAC;;IAEF;IACA,MAAMuB,aAA6B,GAAGN,SAAS,CAAC1C,GAAG,CAACxD,GAAG,IAAI;MAAA,IAAAyG,kBAAA;MACzD,MAAMC,SAAS,GAAGJ,eAAe,CAACtG,GAAG,CAACS,EAAE,CAAC,IAAI,IAAI;MACjD,MAAMkG,OAAO,GAAG5G,aAAa,CAACC,GAAG,CAAC;MAElC,OAAO;QACL,GAAG2G,OAAO;QACVD,SAAS,EAAEA,SAAS,GAAG;UACrBxB,WAAW,EAAEwB,SAAS,CAACxB,WAAW;UAClC0B,qBAAqB,EAAE,EAAAH,kBAAA,GAAAV,YAAY,CAACc,IAAI,CAAC5B,CAAC,IAAIA,CAAC,CAACxE,EAAE,KAAKiG,SAAS,CAACxB,WAAW,CAAC,cAAAuB,kBAAA,uBAAtDA,kBAAA,CAAwD9F,IAAI,KAAI;QACzF,CAAC,GAAG;MACN,CAAC;IACH,CAAC,CAAC;IAEF,OAAO6F,aAAa;EACtB,CAAC,CAAC,OAAOtD,CAAC,EAAE;IACVF,OAAO,CAACC,IAAI,CAAC,mCAAmC,EAAEC,CAAC,CAAC;IACpD,OAAO,EAAE;EACX;AACF;AAEA,OAAO,eAAe4D,aAAaA,CAACC,SAAiB,EAAEC,UAAkC,EAAiB;EACxG,IAAI;IACF,IAAIA,UAAU,KAAK,EAAE,IAAIA,UAAU,KAAK,GAAG,IAAIA,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,IAAI,EAAE;MACzF;MACA,MAAM;QAAEpE;MAAM,CAAC,GAAG,MAAM9C,QAAQ,CAC7B+C,IAAI,CAAC,YAAY,CAAC,CAClBoE,MAAM,CAAC,CAAC,CACRxC,EAAE,CAAC,YAAY,EAAEsC,SAAS,CAAC;MAE9B,IAAInE,KAAK,EAAE;QACT,MAAMA,KAAK;MACb;;MAEA;MACA,IAAIoE,UAAU,KAAK,IAAI,EAAE;QACvB,MAAMzF,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,IAAI,CAAC;QACrF,IAAI,CAACJ,gBAAgB,CAACM,QAAQ,CAACkF,SAAS,CAAC,EAAE;UACzCxF,gBAAgB,CAACmE,IAAI,CAACqB,SAAS,CAAC;UAChCrF,YAAY,CAACwF,OAAO,CAAC,kBAAkB,EAAE1F,IAAI,CAAC2F,SAAS,CAAC5F,gBAAgB,CAAC,CAAC;QAC5E;MACF,CAAC,MAAM;QACL;QACA,MAAMA,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,IAAI,CAAC;QACrF,MAAMyF,eAAe,GAAG7F,gBAAgB,CAACoD,MAAM,CAAElE,EAAU,IAAKA,EAAE,KAAKsG,SAAS,CAAC;QACjFrF,YAAY,CAACwF,OAAO,CAAC,kBAAkB,EAAE1F,IAAI,CAAC2F,SAAS,CAACC,eAAe,CAAC,CAAC;MAC3E;IACF,CAAC,MAAM;MACL;MACA,MAAM7F,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,IAAI,CAAC;MACrF,MAAMyF,eAAe,GAAG7F,gBAAgB,CAACoD,MAAM,CAAElE,EAAU,IAAKA,EAAE,KAAKsG,SAAS,CAAC;MACjFrF,YAAY,CAACwF,OAAO,CAAC,kBAAkB,EAAE1F,IAAI,CAAC2F,SAAS,CAACC,eAAe,CAAC,CAAC;MAEzE,MAAMC,aAAa,GAAG;QACpB7B,UAAU,EAAEuB,SAAS;QACrB7B,WAAW,EAAEoC,QAAQ,CAAC5D,MAAM,CAACsD,UAAU,CAAC;MAC1C,CAAC;;MAED;MACA,MAAM;QAAEpE;MAAM,CAAC,GAAG,MAAM9C,QAAQ,CAC7B+C,IAAI,CAAC,YAAY,CAAC,CAClB0E,MAAM,CAACF,aAAa,CAAC;MAExB,IAAIzE,KAAK,EAAE;QACT,MAAMA,KAAK;MACb;IACF;EACF,CAAC,CAAC,OAAOM,CAAC,EAAE;IACVF,OAAO,CAACJ,KAAK,CAAC,gCAAgC,EAAEM,CAAC,CAAC;IAClD,MAAMA,CAAC;EACT;AACF;;AAEA;AACA,OAAO,SAASsE,iBAAiBA,CAACT,SAAiB,EAAW;EAC5D,MAAMxF,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,kBAAkB,CAAC,IAAI,IAAI,CAAC;EACrF,OAAOJ,gBAAgB,CAACM,QAAQ,CAACkF,SAAS,CAAC;AAC7C;AAEA,OAAO,SAASU,kBAAkBA,CAACd,OAAqB,EAAW;EACjE,OAAO,CAAC,EAAEA,OAAO,CAACD,SAAS,IAAIC,OAAO,CAACD,SAAS,CAACxB,WAAW,IAAI,CAACsC,iBAAiB,CAACb,OAAO,CAAClG,EAAE,CAAC,CAAC;AACjG;AAEA,OAAO,SAASiH,gBAAgBA,CAACf,OAAqB,EAAW;EAC/D,OAAO,CAACA,OAAO,CAACD,SAAS,IAAI,CAACc,iBAAiB,CAACb,OAAO,CAAClG,EAAE,CAAC;AAC7D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}