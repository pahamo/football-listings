{"ast":null,"code":"import { supabase } from './supabase';\n\n// Simple, minimal types\n\n// Only Sky Sports and TNT Sports for simplicity\nexport const SIMPLE_BROADCASTERS = [{\n  id: 1,\n  name: 'Sky Sports'\n}, {\n  id: 2,\n  name: 'TNT Sports'\n}];\n\n// Get fixtures with basic team info using simple JOINs\nexport async function getSimpleFixtures() {\n  try {\n    console.log('[Supabase] Loading full season fixtures (no JOINs)...');\n\n    // Step 1: Load fixture basics only\n    // Use a dynamic season start (Aug 1 of current season year)\n    const now = new Date();\n    const seasonYear = now.getUTCMonth() >= 6 ? now.getUTCFullYear() : now.getUTCFullYear() - 1;\n    const seasonStartIso = `${seasonYear}-08-01T00:00:00.000Z`;\n    const {\n      data: fixtures,\n      error\n    } = await supabase.from('fixtures_with_teams').select('id, utc_kickoff, home_team_id, away_team_id, home_team, away_team, matchday').gte('utc_kickoff', seasonStartIso).order('utc_kickoff', {\n      ascending: true\n    });\n    if (error) {\n      console.error('[Supabase] Error loading fixtures:', error);\n      throw error;\n    }\n    if (!fixtures || fixtures.length === 0) {\n      console.warn('[Supabase] No fixtures returned');\n      return [];\n    }\n\n    // Team names are now included directly from fixtures_with_teams view\n\n    // Step 3: Load broadcasts for these fixtures\n    const fixtureIds = fixtures.map(f => f.id);\n    const {\n      data: broadcasts\n    } = await supabase.from('broadcasts').select('fixture_id, provider_id').in('fixture_id', fixtureIds);\n    const broadcastLookup = {};\n    (broadcasts || []).forEach(b => {\n      broadcastLookup[b.fixture_id] = b.provider_id;\n    });\n\n    // Step 4: Map to simple format\n    return fixtures.map(fixture => {\n      var _SIMPLE_BROADCASTERS$;\n      return {\n        id: fixture.id,\n        kickoff_utc: fixture.utc_kickoff,\n        home_team: fixture.home_team || 'Unknown',\n        away_team: fixture.away_team || 'Unknown',\n        matchweek: fixture.matchday || undefined,\n        broadcaster: ((_SIMPLE_BROADCASTERS$ = SIMPLE_BROADCASTERS.find(b => b.id === broadcastLookup[fixture.id])) === null || _SIMPLE_BROADCASTERS$ === void 0 ? void 0 : _SIMPLE_BROADCASTERS$.name) || undefined\n      };\n    });\n  } catch (error) {\n    console.error('[Supabase] Unexpected error:', error);\n    return [];\n  }\n}\n\n// Save broadcaster assignment (simple)\nexport async function saveBroadcaster(fixtureId, providerId) {\n  try {\n    console.log(`[Supabase] Saving broadcaster for fixture ${fixtureId}: provider ${providerId}`);\n    if (providerId === -1) {\n      // Blackout: remove any broadcaster and mark blackout in localStorage\n      const {\n        error\n      } = await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      if (!blackoutFixtures.includes(fixtureId)) {\n        blackoutFixtures.push(fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n      }\n      console.log(`[Supabase] Set blackout for fixture ${fixtureId}`);\n    } else if (!providerId) {\n      // Remove broadcaster and clear blackout flag\n      const {\n        error\n      } = await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter(id => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Removed broadcaster for fixture ${fixtureId}`);\n    } else {\n      // Add/update broadcaster and clear blackout flag\n      // First delete any existing broadcasts for this fixture to avoid conflicts\n      await supabase.from('broadcasts').delete().eq('fixture_id', fixtureId);\n\n      // Then insert the new broadcast\n      const {\n        error\n      } = await supabase.from('broadcasts').insert({\n        fixture_id: fixtureId,\n        provider_id: providerId\n      });\n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter(id => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Saved broadcaster for fixture ${fixtureId}`);\n    }\n  } catch (error) {\n    console.error(`[Supabase] Error saving broadcaster:`, error);\n    throw error;\n  }\n}","map":{"version":3,"names":["supabase","SIMPLE_BROADCASTERS","id","name","getSimpleFixtures","console","log","now","Date","seasonYear","getUTCMonth","getUTCFullYear","seasonStartIso","data","fixtures","error","from","select","gte","order","ascending","length","warn","fixtureIds","map","f","broadcasts","in","broadcastLookup","forEach","b","fixture_id","provider_id","fixture","_SIMPLE_BROADCASTERS$","kickoff_utc","utc_kickoff","home_team","away_team","matchweek","matchday","undefined","broadcaster","find","saveBroadcaster","fixtureId","providerId","delete","eq","blackoutFixtures","JSON","parse","localStorage","getItem","includes","push","setItem","stringify","updated","filter","insert"],"sources":["/Users/p/Documents/pl_tv_mvp_spa/react-version/src/services/supabase-simple.ts"],"sourcesContent":["import { supabase } from './supabase';\n\n// Simple, minimal types\nexport interface SimpleFixture {\n  id: number;\n  kickoff_utc: string;\n  home_team: string;\n  away_team: string;\n  broadcaster?: string;\n  matchweek?: number;\n}\n\n// Only Sky Sports and TNT Sports for simplicity\nexport const SIMPLE_BROADCASTERS = [\n  { id: 1, name: 'Sky Sports' },\n  { id: 2, name: 'TNT Sports' }\n];\n\n// Get fixtures with basic team info using simple JOINs\nexport async function getSimpleFixtures(): Promise<SimpleFixture[]> {\n  try {\n    console.log('[Supabase] Loading full season fixtures (no JOINs)...');\n\n    // Step 1: Load fixture basics only\n    // Use a dynamic season start (Aug 1 of current season year)\n    const now = new Date();\n    const seasonYear = now.getUTCMonth() >= 6 ? now.getUTCFullYear() : now.getUTCFullYear() - 1;\n    const seasonStartIso = `${seasonYear}-08-01T00:00:00.000Z`;\n\n    const { data: fixtures, error } = await supabase\n      .from('fixtures_with_teams')\n      .select('id, utc_kickoff, home_team_id, away_team_id, home_team, away_team, matchday')\n      .gte('utc_kickoff', seasonStartIso)\n      .order('utc_kickoff', { ascending: true });\n\n    if (error) {\n      console.error('[Supabase] Error loading fixtures:', error);\n      throw error;\n    }\n    if (!fixtures || fixtures.length === 0) {\n      console.warn('[Supabase] No fixtures returned');\n      return [];\n    }\n\n    // Team names are now included directly from fixtures_with_teams view\n\n    // Step 3: Load broadcasts for these fixtures\n    const fixtureIds = fixtures.map((f: any) => f.id);\n    const { data: broadcasts } = await supabase\n      .from('broadcasts')\n      .select('fixture_id, provider_id')\n      .in('fixture_id', fixtureIds);\n\n    const broadcastLookup: Record<number, number> = {};\n    (broadcasts || []).forEach((b: any) => {\n      broadcastLookup[b.fixture_id] = b.provider_id;\n    });\n\n    // Step 4: Map to simple format\n    return fixtures.map((fixture: any) => ({\n      id: fixture.id,\n      kickoff_utc: fixture.utc_kickoff,\n      home_team: fixture.home_team || 'Unknown',\n      away_team: fixture.away_team || 'Unknown',\n      matchweek: fixture.matchday || undefined,\n      broadcaster: SIMPLE_BROADCASTERS.find(b => b.id === broadcastLookup[fixture.id])?.name || undefined,\n    }));\n  } catch (error) {\n    console.error('[Supabase] Unexpected error:', error);\n    return [];\n  }\n}\n\n// Save broadcaster assignment (simple)\nexport async function saveBroadcaster(fixtureId: number, providerId: number | null): Promise<void> {\n  try {\n    console.log(`[Supabase] Saving broadcaster for fixture ${fixtureId}: provider ${providerId}`);\n    \n    if (providerId === -1) {\n      // Blackout: remove any broadcaster and mark blackout in localStorage\n      const { error } = await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n      if (error) throw error;\n\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      if (!blackoutFixtures.includes(fixtureId)) {\n        blackoutFixtures.push(fixtureId);\n        localStorage.setItem('blackoutFixtures', JSON.stringify(blackoutFixtures));\n      }\n      console.log(`[Supabase] Set blackout for fixture ${fixtureId}`);\n\n    } else if (!providerId) {\n      // Remove broadcaster and clear blackout flag\n      const { error } = await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n        \n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter((id: number) => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Removed broadcaster for fixture ${fixtureId}`);\n    } else {\n      // Add/update broadcaster and clear blackout flag\n      // First delete any existing broadcasts for this fixture to avoid conflicts\n      await supabase\n        .from('broadcasts')\n        .delete()\n        .eq('fixture_id', fixtureId);\n\n      // Then insert the new broadcast\n      const { error } = await supabase\n        .from('broadcasts')\n        .insert({\n          fixture_id: fixtureId,\n          provider_id: providerId\n        });\n        \n      if (error) throw error;\n      const blackoutFixtures = JSON.parse(localStorage.getItem('blackoutFixtures') || '[]');\n      const updated = blackoutFixtures.filter((id: number) => id !== fixtureId);\n      localStorage.setItem('blackoutFixtures', JSON.stringify(updated));\n      console.log(`[Supabase] Saved broadcaster for fixture ${fixtureId}`);\n    }\n  } catch (error) {\n    console.error(`[Supabase] Error saving broadcaster:`, error);\n    throw error;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}